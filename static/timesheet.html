<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Edit Day — Employee Timesheet (Inline)</title>
    <style>
      :root {
        --line: #e5e7eb;
        --muted: #6b7280;
        --ok: #16a34a;
        --err: #dc2626;
      }
      body {
        font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial;
        margin: 0;
        padding: 20px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 22px;
      }
      .muted {
        color: var(--muted);
      }
      .page-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin: 0 0 12px;
      }
      .spacer {
        flex: 1;
      }
      a {
        color: #2563eb;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        margin: 12px 0;
      }
      th,
      td {
        border: 1px solid var(--line);
        padding: 6px 8px;
        text-align: center;
        vertical-align: middle;
      }
      th {
        background: #f8fafc;
      }
      .left {
        text-align: left;
      }
      .num {
        text-align: right;
      }
      .mono {
        font-variant-numeric: tabular-nums;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      button {
        padding: 6px 10px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #111;
        color: #fff;
        cursor: pointer;
      }
      button.secondary {
        background: #fff;
        color: #111;
      }
      input[type="datetime-local"],
      input[type="text"],
      input[type="number"],
      select {
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 8px;
        width: 100%;
      }
      .empty {
        color: var(--muted);
        padding: 10px;
        text-align: center;
      }
      .row-select {
        cursor: pointer;
      }
      .cell-editing {
        background: #fffbe6;
        box-shadow: inset 0 0 0 1px #facc15;
      }
      .toast {
        position: fixed;
        right: 16px;
        bottom: 16px;
        background: #111;
        color: #fff;
        padding: 10px 12px;
        border-radius: 10px;
        opacity: 0;
        transform: translateY(6px);
        transition: 0.2s;
      }
      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }
      .toast.ok {
        background: var(--ok);
      }
      .toast.err {
        background: var(--err);
      }
      .dirty::after {
        content: "•";
        margin-left: 4px;
        color: #f59e0b;
      }
    </style>
  </head>
  <body>
    <div class="page-header">
      <h1 id="header">Edit Day</h1>
      <div class="spacer"></div>
      <a id="backLink" href="#" onclick="history.back();return false;"
        >← Back</a
      >
    </div>
    <div class="muted" id="subHeader"></div>

    <!-- Shifts -->
    <div class="controls">
      <strong>Shifts</strong>
      <button id="addShift">+ Add shift</button>
    </div>
    <table aria-label="Shifts">
      <thead>
        <tr>
          <th style="width: 64px">No</th>
          <th style="width: 220px">Clock In</th>
          <th style="width: 220px">Clock Out</th>
          <th style="width: 160px">Status</th>
          <th>Notes</th>
          <th style="width: 120px">Action</th>
        </tr>
      </thead>
      <tbody id="shiftBody">
        <tr>
          <td colspan="6" class="empty">Loading…</td>
        </tr>
      </tbody>
    </table>

    <!-- Breaks -->
    <div class="controls">
      <strong>Breaks</strong>
      <span id="breaksFor" class="muted">(select a shift)</span>
      <button id="addBreak" disabled>+ Add break</button>
    </div>
    <table aria-label="Breaks">
      <thead>
        <tr>
          <th style="width: 64px">No</th>
          <th style="width: 180px">Type</th>
          <th style="width: 220px">Start</th>
          <th style="width: 220px">End</th>
          <th style="width: 120px">Paid?</th>
          <th style="width: 120px">Action</th>
        </tr>
      </thead>
      <tbody id="breakBody">
        <tr>
          <td colspan="6" class="empty">No shift selected</td>
        </tr>
      </tbody>
    </table>

    <div id="toast" class="toast"><span id="toastText"></span></div>

    <script type="module">
      import { jfetch } from "/static/js/api.js?v=1";
      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) =>
        Array.from(root.querySelectorAll(sel));

      // ===== Toast =====
      function toast(msg, ok = true) {
        const box = $("#toast"),
          txt = $("#toastText");
        txt.textContent = msg;
        box.classList.remove("ok", "err");
        box.classList.add(ok ? "ok" : "err", "show");
        setTimeout(() => box.classList.remove("show"), 1600);
      }

      // ===== API helpers (expects jfetch to JSON/throw on error) =====
      const API_BASE = "";
      const api = (p) => `${API_BASE}${p}`;
      const GET = (p) => jfetch(api(p));
      const POST = (p, b) =>
        jfetch(api(p), { method: "POST", body: JSON.stringify(b) });
      const PATCH = (p, b) =>
        jfetch(api(p), { method: "PATCH", body: JSON.stringify(b) });
      const DELETE_ = (p) => jfetch(api(p), { method: "DELETE" });

      // Endpoints
      const PP = "/pay-periods",
        EMP = "/employees",
        TE_LIST = "/time-entries",
        TE_MANUAL = "/time-entries/manual",
        BR_MANUAL = "/breaks/manual";

      // ===== Utilities =====
      const pad = (n) => String(n).padStart(2, "0");
      const fmtDate = (iso) =>
        iso ? new Date(iso).toISOString().slice(0, 10) : "";
      const qs = (k) => new URL(location.href).searchParams.get(k);
      const dayKey = (iso) =>
        iso ? new Date(iso).toISOString().slice(0, 10) : null;

      const toLocalInput = (iso) => {
        if (!iso) return "";
        const d = new Date(iso);
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(
          d.getDate()
        )}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
      };
      const fromLocalInput = (s) => (s ? new Date(s).toISOString() : null);
      const displayDT = (iso) =>
        iso ? toLocalInput(iso).replace("T", " ") : "";

      // ===== State =====
      let pp = null,
        emp = null,
        details = [];
      let selectedShiftId = null;
      let currentEmployeeId = null,
        currentPpId = null,
        targetDate = null;

      // ===== Fetch day entries =====
      async function reloadDetails() {
        const start = new Date(`${targetDate}T00:00:00Z`).toISOString();
        const end = new Date(
          new Date(start).getTime() + 24 * 60 * 60 * 1000
        ).toISOString();
        details = await GET(
          `${TE_LIST}/range?employee_id=${encodeURIComponent(
            currentEmployeeId
          )}&start_at=${encodeURIComponent(start)}&end_at=${encodeURIComponent(
            end
          )}`
        );
      }

      // ===== Inline editor core =====
      let openEditorCell = null;

      function closeOpenEditor(commit = false) {
        if (!openEditorCell) return;
        const input = $(".inline-editor", openEditorCell);
        if (!input) {
          openEditorCell.classList.remove("cell-editing");
          openEditorCell = null;
          return;
        }
        if (commit) {
          // trigger blur -> commit; if it's checkbox we simulate change already handled
          input.blur();
        } else {
          // rollback: re-render whole tables (cheap, keeps code simple)
          openEditorCell.classList.remove("cell-editing");
          openEditorCell = null;
          renderShifts();
          if (selectedShiftId) renderBreaks();
        }
      }

      function editableCellsInRow(tr) {
        // order: clock in, clock out, status, notes
        return $$(".editable", tr);
      }

      function focusMove(currentTd, dir) {
        const tr = currentTd.closest("tr");
        if (!tr) return;
        const cells = editableCellsInRow(tr);
        const idx = cells.indexOf(currentTd);
        const next = cells[idx + (dir > 0 ? 1 : -1)];
        if (next) {
          next.click(); // will open editor & focus
        } else {
          // move to next/prev row
          const rows = Array.from(tr.parentElement.children);
          const rIdx = rows.indexOf(tr);
          const nr = rows[rIdx + (dir > 0 ? 1 : -1)];
          if (nr) {
            const nCells = editableCellsInRow(nr);
            const target = dir > 0 ? nCells[0] : nCells[nCells.length - 1];
            target?.click();
          }
        }
      }

      function makeInlineEditor(td, { type, value, save }) {
        if (openEditorCell && openEditorCell !== td) closeOpenEditor(false);
        if (td.querySelector(".inline-editor")) return;

        const isCheckbox = type === "checkbox";
        td.classList.add("cell-editing");
        openEditorCell = td;

        let input;
        if (type === "datetime") {
          input = document.createElement("input");
          input.type = "datetime-local";
          input.value = toLocalInput(value) || "";
        } else if (type === "text") {
          input = document.createElement("input");
          input.type = "text";
          input.value = value ?? "";
        } else if (type === "select-status") {
          input = document.createElement("select");
          const OPTS = ["open", "closed", "cancelled"];
          const blank = new Option("(empty)", "");
          input.appendChild(blank);
          for (const o of OPTS) {
            input.appendChild(new Option(o, o, false, o === value));
          }
        } else if (type === "checkbox") {
          input = document.createElement("input");
          input.type = "checkbox";
          input.checked = !!value;
          const label = document.createElement("label");
          label.style.display = "inline-flex";
          label.style.alignItems = "center";
          label.style.gap = "6px";
          label.className = "inline-editor";
          const txt = document.createElement("span");
          txt.textContent = "Paid";
          label.appendChild(input);
          label.appendChild(txt);
          td.innerHTML = "";
          td.appendChild(label);
          input.addEventListener("change", async () => {
            try {
              await save(input.checked);
              toast("Saved");
            } catch (e) {
              /* toast in save path */
            } finally {
              td.classList.remove("cell-editing");
              openEditorCell = null;
              await reloadDetails();
              renderBreaks();
            }
          });
          input.addEventListener("keydown", (ev) => {
            if (ev.key === "Escape") {
              ev.preventDefault();
              td.classList.remove("cell-editing");
              openEditorCell = null;
              renderBreaks();
            }
            if (ev.key === "Tab") {
              ev.preventDefault();
              focusMove(td, ev.shiftKey ? -1 : 1);
            }
          });
          input.focus();
          return;
        } else {
          return;
        }

        input.className = "inline-editor";
        td.innerHTML = "";
        td.appendChild(input);
        input.focus();
        if (input.setSelectionRange && input.type === "text") {
          const L = input.value.length;
          input.setSelectionRange(L, L);
        }

        const commit = async () => {
          let newVal;
          if (type === "datetime")
            newVal = input.value ? fromLocalInput(input.value) : null;
          else if (type === "text") newVal = input.value || null;
          else if (type === "select-status") newVal = input.value || null;

          try {
            await save(newVal);
            td.classList.remove("dirty");
            toast("Saved");
          } catch (e) {
            /* toast set by api */
          } finally {
            td.classList.remove("cell-editing");
            openEditorCell = null;
            await reloadDetails();
            renderShifts();
            if (selectedShiftId) renderBreaks();
          }
        };
        const rollback = () => {
          td.classList.remove("cell-editing");
          openEditorCell = null;
          renderShifts();
          if (selectedShiftId) renderBreaks();
        };

        input.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            commit();
          } else if (ev.key === "Escape") {
            ev.preventDefault();
            rollback();
          } else if (ev.key === "Tab") {
            ev.preventDefault();
            commit().then(() => focusMove(td, ev.shiftKey ? -1 : 1));
          }
        });
        input.addEventListener("blur", commit);
      }

      // ===== Render Shifts =====
      function renderShifts() {
        const tb = $("#shiftBody");
        tb.innerHTML = "";
        const dayRows = details
          .filter(
            (te) => dayKey(te.clock_in_at || te.clock_out_at) === targetDate
          )
          .sort(
            (a, b) =>
              new Date(a.clock_in_at || 0) - new Date(b.clock_in_at || 0)
          );

        if (!dayRows.length) {
          tb.innerHTML = `<tr><td colspan="6" class="empty">No shifts</td></tr>`;
          $(
            "#breakBody"
          ).innerHTML = `<tr><td colspan="6" class="empty">No shift selected</td></tr>`;
          selectedShiftId = null;
          $("#addBreak").disabled = true;
          $("#breaksFor").textContent = "(select a shift)";
          return;
        }

        dayRows.forEach((te, i) => {
          const tr = document.createElement("tr");
          tr.className = "row-select";
          tr.dataset.id = te.id;

          const tdNo = document.createElement("td");
          tdNo.className = "num mono";
          tdNo.textContent = String(i + 1);

          const tdIn = document.createElement("td");
          tdIn.className = "mono editable";
          tdIn.textContent = displayDT(te.clock_in_at);
          tdIn.title = "Click to edit";
          tdIn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            makeInlineEditor(tdIn, {
              type: "datetime",
              value: te.clock_in_at,
              save: (v) => PATCH(`${TE_MANUAL}/${te.id}`, { clock_in_at: v }),
            });
          });

          const tdOut = document.createElement("td");
          tdOut.className = "mono editable";
          tdOut.textContent = displayDT(te.clock_out_at);
          tdOut.title = "Click to edit";
          tdOut.addEventListener("click", (ev) => {
            ev.stopPropagation();
            makeInlineEditor(tdOut, {
              type: "datetime",
              value: te.clock_out_at,
              save: (v) => PATCH(`${TE_MANUAL}/${te.id}`, { clock_out_at: v }),
            });
          });

          const tdStatus = document.createElement("td");
          tdStatus.className = "editable";
          tdStatus.textContent = te.status || "";
          tdStatus.title = "Click to edit";
          tdStatus.addEventListener("click", (ev) => {
            ev.stopPropagation();
            makeInlineEditor(tdStatus, {
              type: "select-status",
              value: te.status || "",
              save: (v) => PATCH(`${TE_MANUAL}/${te.id}`, { status: v }),
            });
          });

          const tdNotes = document.createElement("td");
          tdNotes.className = "left editable";
          tdNotes.textContent = te.notes || "";
          tdNotes.title = "Click to edit";
          tdNotes.addEventListener("click", (ev) => {
            ev.stopPropagation();
            makeInlineEditor(tdNotes, {
              type: "text",
              value: te.notes || "",
              save: (v) => PATCH(`${TE_MANUAL}/${te.id}`, { notes: v }),
            });
          });

          const tdAct = document.createElement("td");
          const btnDel = document.createElement("button");
          btnDel.textContent = "Delete";
          btnDel.className = "secondary";
          btnDel.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            if (!confirm("Delete this shift?")) return;
            try {
              await DELETE_(`${TE_MANUAL}/${te.id}`);
            } catch (e) {
              try {
                await PATCH(`${TE_MANUAL}/${te.id}`, {
                  status: "cancelled",
                  notes: (te.notes || "") + " [deleted]",
                });
              } catch (err) {
                toast(err?.message || "Delete failed", false);
                return;
              }
            }
            toast("Deleted");
            await reloadDetails();
            renderShifts();
            if (selectedShiftId === te.id) {
              selectedShiftId = null;
              $(
                "#breakBody"
              ).innerHTML = `<tr><td colspan="6" class="empty">No shift selected</td></tr>`;
              $("#addBreak").disabled = true;
              $("#breaksFor").textContent = "(select a shift)";
            }
          });
          tdAct.appendChild(btnDel);

          tr.append(tdNo, tdIn, tdOut, tdStatus, tdNotes, tdAct);

          tr.addEventListener("click", () => {
            selectedShiftId = te.id;
            $("#breaksFor").textContent = `for Shift #${i + 1}`;
            $("#addBreak").disabled = false;
            renderBreaks();
          });

          tb.appendChild(tr);
        });

        if (!selectedShiftId) {
          selectedShiftId = dayRows[0].id;
          $("#breaksFor").textContent = `for Shift #1`;
          $("#addBreak").disabled = false;
          renderBreaks();
        }
      }

      // ===== Render Breaks =====
      function renderBreaks() {
        const tb = $("#breakBody");
        tb.innerHTML = "";
        if (!selectedShiftId) {
          tb.innerHTML = `<tr><td colspan="6" class="empty">No shift selected</td></tr>`;
          return;
        }

        const te = details.find((x) => x.id === selectedShiftId);
        const list = (te?.breaks || [])
          .slice()
          .sort(
            (a, b) => new Date(a.start_at || 0) - new Date(b.start_at || 0)
          );

        if (!list.length) {
          tb.innerHTML = `<tr><td colspan="6" class="empty">No breaks</td></tr>`;
          return;
        }

        list.forEach((b, i) => {
          const tr = document.createElement("tr");
          tr.dataset.id = b.id;

          const tdNo = document.createElement("td");
          tdNo.className = "num mono";
          tdNo.textContent = String(i + 1);

          const tdType = document.createElement("td");
          tdType.className = "editable";
          tdType.textContent = b.break_type || "";
          tdType.title = "Click to edit";
          tdType.addEventListener("click", () => {
            makeInlineEditor(tdType, {
              type: "text",
              value: b.break_type || "",
              save: (v) => PATCH(`${BR_MANUAL}/${b.id}`, { break_type: v }),
            });
          });

          const tdStart = document.createElement("td");
          tdStart.className = "mono editable";
          tdStart.textContent = displayDT(b.start_at);
          tdStart.title = "Click to edit";
          tdStart.addEventListener("click", () => {
            makeInlineEditor(tdStart, {
              type: "datetime",
              value: b.start_at,
              save: (v) => PATCH(`${BR_MANUAL}/${b.id}`, { start_at: v }),
            });
          });

          const tdEnd = document.createElement("td");
          tdEnd.className = "mono editable";
          tdEnd.textContent = displayDT(b.end_at);
          tdEnd.title = "Click to edit";
          tdEnd.addEventListener("click", () => {
            makeInlineEditor(tdEnd, {
              type: "datetime",
              value: b.end_at,
              save: (v) => PATCH(`${BR_MANUAL}/${b.id}`, { end_at: v }),
            });
          });

          const tdPaid = document.createElement("td");
          tdPaid.className = "editable";
          tdPaid.textContent = b.is_paid ? "Yes" : "No";
          tdPaid.title = "Click to toggle/edit";
          tdPaid.addEventListener("click", () => {
            makeInlineEditor(tdPaid, {
              type: "checkbox",
              value: b.is_paid,
              save: (v) => PATCH(`${BR_MANUAL}/${b.id}`, { is_paid: !!v }),
            });
          });

          const tdAct = document.createElement("td");
          const btnDel = document.createElement("button");
          btnDel.textContent = "Delete";
          btnDel.className = "secondary";
          btnDel.addEventListener("click", async () => {
            if (!confirm("Delete this break?")) return;
            try {
              await DELETE_(`${BR_MANUAL}/${b.id}`);
            } catch (e) {
              toast(
                "Backend has no DELETE /breaks/manual/{id}. Please add it.",
                false
              );
              return;
            }
            toast("Deleted");
            await reloadDetails();
            renderBreaks();
          });
          tdAct.appendChild(btnDel);

          tr.append(tdNo, tdType, tdStart, tdEnd, tdPaid, tdAct);
          tb.appendChild(tr);
        });
      }

      // ===== Add shift / break =====
      $("#addShift").addEventListener("click", async () => {
        const s = `${targetDate}T09:00`,
          e = `${targetDate}T18:00`;
        const payload = {
          employee_id: Number(currentEmployeeId),
          clock_in_at: fromLocalInput(s),
          clock_out_at: fromLocalInput(e),
          clock_in_method: "manual",
          clock_out_method: "manual",
          status: "closed",
          notes: "",
        };
        await POST(TE_MANUAL, payload);
        toast("Shift added");
        await reloadDetails();
        renderShifts();
      });

      $("#addBreak").addEventListener("click", async () => {
        if (!selectedShiftId) return;
        const s = `${targetDate}T12:00`,
          e = `${targetDate}T12:30`;
        const payload = {
          time_entry_id: selectedShiftId,
          break_type: "lunch",
          start_at: fromLocalInput(s),
          end_at: fromLocalInput(e),
          method: "manual",
          is_paid: false,
        };
        await POST(BR_MANUAL, payload);
        toast("Break added");
        await reloadDetails();
        renderBreaks();
      });

      // ===== Page load =====
      async function loadPage() {
        currentPpId = qs("pp_id");
        currentEmployeeId = qs("employee_id");
        targetDate = qs("date");
        if (!currentPpId || !currentEmployeeId || !targetDate) {
          $("#header").textContent = "Edit Day — Missing params";
          return;
        }
        try {
          pp = await GET(`${PP}/${currentPpId}`);
        } catch {}
        try {
          emp = await GET(`${EMP}/${currentEmployeeId}`);
        } catch {}
        $("#header").textContent = `Edit Day — ${
          emp?.name ?? "Emp #" + currentEmployeeId
        }`;
        $("#subHeader").textContent = `Pay Period: ${fmtDate(
          pp?.start_at
        )} → ${fmtDate(pp?.end_at)} | Date: ${targetDate}`;

        const url = new URL(location.href);
        const ret = url.searchParams.get("return");
        $("#backLink").href =
          ret ||
          `timesheet.html?pp_id=${encodeURIComponent(
            currentPpId
          )}&employee_id=${encodeURIComponent(currentEmployeeId)}`;

        await reloadDetails();
        renderShifts();
      }

      document.addEventListener("click", (e) => {
        // click outside any editing cell -> commit the open editor
        if (openEditorCell && !openEditorCell.contains(e.target))
          closeOpenEditor(true);
      });

      document.addEventListener("keydown", (e) => {
        // global Esc to cancel editor
        if (e.key === "Escape" && openEditorCell) {
          e.preventDefault();
          closeOpenEditor(false);
        }
      });

      document.addEventListener("DOMContentLoaded", loadPage);
    </script>
  </body>
</html>
