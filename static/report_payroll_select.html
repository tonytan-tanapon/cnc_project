<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Payroll Report (Per-Employee Per-Day) — DB Pay Period & Rates (OT Included)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{--text:#111;--muted:#6b7280;--line:#e5e7eb;--btn:#374151;--acc:#2563eb;--ok:#16a34a;--warn:#d97706;--err:#b91c1c;--bg:#fff}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .wrap{max-width:1200px;margin:28px auto;padding:0 14px}
    h1{margin:0 0 12px;font-size:22px}
    .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:14px;margin-bottom:14px}
    label{display:block;margin:6px 0 4px;font-weight:600}
    input,select,textarea{width:100%;padding:9px 11px;border:1px solid var(--line);border-radius:10px;background:#fff}
    input:focus,select:focus,textarea:focus{outline:2px solid #c7d2fe;border-color:#c7d2fe}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:end}
    .btn{border:none;border-radius:10px;padding:9px 12px;cursor:pointer;font-weight:700;color:#fff;background:var(--btn)}
    .btn.acc{background:var(--acc)} .btn.ok{background:var(--ok)} .btn.warn{background:var(--warn)} .btn.err{background:var(--err)}
    table{width:100%;border-collapse:collapse;border:1px solid var(--line);border-radius:12px;overflow:hidden}
    th,td{padding:10px 12px;border-bottom:1px solid var(--line);vertical-align:top;text-align:left}
    th{background:#f9fafb}
    tfoot td{background:#f3f4f6;font-weight:700}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .right{margin-left:auto}
    .hidden{display:none}
    .sum{font-weight:700}
    .nowrap{white-space:nowrap}
    .num{text-align:right}
    .chip{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef2ff;border:1px solid #e5e7eb;font-size:12px}
    tr.details{background:#fbfbff}
    /* Hybrid employee controls */
    .emp-wrap{display:flex;gap:8px;align-items:center}
    .emp-wrap > input{min-width:220px;flex:1}
    .emp-wrap > select{min-width:220px;flex:1}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Payroll Report</h1>

  <!-- Filters -->
  <div class="card">
    <div class="row">
      <div style="min-width:480px">
        <label>Employee</label>
        <div class="emp-wrap">
          <!-- 1) Type to search with autocomplete -->
          <input id="f_emp_search" type="text" list="emp_suggest" placeholder="Type name or code…" autocomplete="off">
          <datalist id="emp_suggest"></datalist>

          <!-- 2) Or pick from a full select -->
          <select id="f_emp_select">
            <option value="">— Select employee —</option>
          </select>

          <!-- Hidden ID used by calculations -->
          <input id="f_emp_id" type="hidden">
        </div>
      </div>

      <div style="min-width:260px">
        <label>Pay Period</label>
        <select id="f_period" onchange="onPeriodChange()">
          <option value="">Pay Period —</option>
        </select>
      </div>
      <div style="min-width:210px">
        <label>Start (date)</label>
        <input id="f_start" type="date">
      </div>
      <div style="min-width:210px">
        <label>End (date)</label>
        <input id="f_end" type="date">
      </div>

      <div style="min-width:180px">
        <label class="small muted" style="display:flex;align-items:center;gap:8px">
          <input id="f_use_rate_db" type="checkbox" checked>Rate from database
        </label>
      </div>
      <div style="min-width:160px">
        <label>Default Rate</label>
        <input id="f_rate" type="number" step="0.01" value="10">
      </div>

      <div style="min-width:260px">
        <label>&nbsp;</label>
        <div class="row" style="gap:6px">
          <label class="small muted" style="display:flex;align-items:center;gap:8px">
            <input id="f_closed_only" type="checkbox" checked>Close TimeEntry
          </label>
          <button class="btn" onclick="loadReport()">Calculate</button>
          <button class="btn ok" onclick="exportCSV()">Export CSV</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Table -->
  <div class="card">
    <div><div id="emp_info"></div></div>
    <div class="row small muted">
      <div class="right">Total hour: <span id="sumHours" class="sum">0.00</span> h · Total pay: <span id="sumPay" class="sum">0.00</span></div>
    </div>
    <table id="tbl">
      <thead>
        <tr>
          <th></th>
          <th class="nowrap">Date</th>
          <th>Clock In</th>
          <th>Clock Out</th>
          <th>Break (unpaid)</th>
          <th class="num">Reg (h)</th>
          <th class="num">OT (h)</th>
          <th class="num">Rate</th>
          <th class="num">OT Rate</th>
          <th class="num">Pay (Reg)</th>
          <th class="num">Pay (OT)</th>
          <th class="num">Total pay</th>
        </tr>
      </thead>
      <tbody id="tblBody"></tbody>
      <tfoot id="tblFoot"></tfoot>
    </table>
  </div>
</div>

<!-- App -->
<script type="module">
  import { $ as _$, jfetch, toast } from "/static/js/api.js?v=1";
  const $ = (sel) => document.querySelector(sel);

  /* API base */
  const API_BASE = ''; // same-origin
  const api = (p) => `${API_BASE}${p}`;
  async function apiGET(path){
    try{ return await jfetch(api(path)); }
    catch(e){ console.error('API error', e); toast?.(e?.message || 'API error'); throw e; }
  }

  /* Endpoints */
  const TE = "/time-entries";        // /time-entries/range
  const PP = "/pay-periods";
  const PR = "/pay-rates";
  const PR_BULK = "/pay-rates/bulk";
  const EMP = "/employees";

  /* OT rules */
  const DAILY_OT1_THRESHOLD = 8;
  const DEFAULT_OT_MULTIPLIER = 1.5;

  /* Utils */
  const esc = s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  const pad = n => String(n).padStart(2,'0');
  const sum = arr => arr.reduce((a,b)=>a+b,0);
  const CCY_SYM = '$';
  const currency = v => CCY_SYM + ' ' + Number(v||0).toFixed(2);
  function toLocalISODate(dt){ const y=dt.getFullYear(), m=pad(dt.getMonth()+1), d=pad(dt.getDate()); return `${y}-${m}-${d}`; }
  function toISODate(d){ return d ? d + "T00:00:00" : null; }
  function addDaysStr(yyyy_mm_dd, days){ const dt = new Date(yyyy_mm_dd+"T00:00:00"); dt.setDate(dt.getDate()+days); return toLocalISODate(dt); }
  function toISODateEndExclusive(d){ return d ? addDaysStr(d,1) + "T00:00:00" : null; }
  function localDateKey(iso){ const d=new Date(iso); if(isNaN(d)) return ''; return toLocalISODate(d); }
  function fmtTime(iso){ if(!iso) return ''; const d=new Date(iso); if(isNaN(d)) return ''; return `${pad(d.getHours())}:${pad(d.getMinutes())}`; }
  function durHours(isoStart, isoEnd){ if(!isoStart || !isoEnd) return 0; const s=new Date(isoStart), e=new Date(isoEnd); if(isNaN(s)||isNaN(e)||e<=s) return 0; return (e-s)/3600000; }

  function getOverrides(){ try{ return JSON.parse(localStorage.getItem('payroll_rate_overrides')||'{}'); }catch{ return {}; } }
  function setOverrides(map){ localStorage.setItem('payroll_rate_overrides', JSON.stringify(map||{})); }

  /* Employee directory storage */
  const EMP_MAP_BY_ID = new Map();   // id -> {id,name,emp_code}
  const EMP_LIST = [];               // ordered list for select/datalist

  /* Display formats */
  const labelForSelect = (e) => e.emp_code ? `${e.emp_code} — ${e.name||''}`.trim() : (e.name||`#${e.id}`);
  const labelForDatalist = (e) => e.name ? `${e.name}${e.emp_code?` (${e.emp_code})`:''}` : (e.emp_code||`#${e.id}`);
  const displayEmpHeader = (e) => e.name || '';

  /* ==== PAY PERIOD ==== */
  let PAY_PERIODS = [];
  async function loadPayPeriods(){
    try{
      PAY_PERIODS = await apiGET(PP);
      const sel = $('#f_period');
      PAY_PERIODS.sort((a,b)=> (b.start_at||'').localeCompare(a.start_at||''));
      for(const p of PAY_PERIODS){
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = `${p.name||p.id} — ${toLocalISODate(new Date(p.start_at))} → ${toLocalISODate(new Date(p.end_at))} (${p.status||''})`;
        sel.appendChild(opt);
      }
    }catch(e){ console.warn('loadPayPeriods failed', e); }
  }

  function onPeriodChange(){
    const id = $('#f_period').value;
    if(!id) return;
    const p = PAY_PERIODS.find(x => String(x.id) === String(id));
    if(!p) return;
    const start = new Date(p.start_at);
    const end   = new Date(p.end_at);
    let days = Math.ceil((end - start) / 86400000);
    if (!Number.isFinite(days) || days < 1) days = 1;
    const endInclusive = new Date(start); endInclusive.setDate(start.getDate() + days);
    $('#f_start').value = toLocalISODate(start);
    $('#f_end').value   = toLocalISODate(endInclusive);
  }

  /* ==== RATES ==== */
  let PAY_RATES = {};
  async function loadRatesForEmployees(empIds){
    const ids = Array.from(empIds||[]).map(x=>String(x));
    if(!ids.length){ PAY_RATES = {}; return; }

    try{
      const data = await apiGET(`${PR_BULK}?employee_ids=${encodeURIComponent(ids.join(','))}`);
      PAY_RATES = {};
      for(const row of (data||[])){
        const eid = row.employee_id;
        if(!PAY_RATES[eid]) PAY_RATES[eid] = [];
        PAY_RATES[eid].push(row);
      }
      for(const k in PAY_RATES){
        PAY_RATES[k].sort((a,b)=> (a.effective_from||'').localeCompare(b.effective_from||''));
      }
      return;
    }catch(e){ /* fallback */ }

    PAY_RATES = {};
    for(const eid of ids){
      try{
        const list = await apiGET(`${PR}?employee_id=${encodeURIComponent(eid)}`);
        PAY_RATES[eid] = (list||[]).sort((a,b)=> (a.effective_from||'').localeCompare(b.effective_from||''));
      }catch(err){ console.warn('loadRates emp failed', eid, err); PAY_RATES[eid] = []; }
    }
  }
  function effectiveRateFor(empId, atIso){
    const arr = PAY_RATES[empId]||[];
    if(!arr.length) return null;
    const at = atIso ? new Date(atIso) : null;
    let chosen = null;
    for(const r of arr){
      if(!r.effective_from){ chosen = r; continue; }
      const eff = new Date(r.effective_from);
      if(!at || eff <= at){ chosen = r; } else { break; }
    }
    return chosen;
  }
  function splitDailyHours(net){
    const reg = Math.max(0, Math.min(net, DAILY_OT1_THRESHOLD));
    const ot  = Math.max(0, net - DAILY_OT1_THRESHOLD);
    return { regHours: reg, ot1Hours: ot };
  }

  /* ==== EMPLOYEE HYBRID CONTROLS ==== */

  // Populate both the datalist (for typing) and the select (for picking)
  function populateEmployeeControls(list){
    const dl = $('#emp_suggest');
    const sel = $('#f_emp_select');
    dl.innerHTML = '';
    sel.innerHTML = '<option value="">— Select employee —</option>';

    EMP_MAP_BY_ID.clear();
    EMP_LIST.length = 0;

    for(const e of (list||[])){
      const entry = { id:String(e.id), name:e.name||'', emp_code:e.emp_code||'' };
      EMP_MAP_BY_ID.set(entry.id, entry);
      EMP_LIST.push(entry);

      // datalist option (shows Name (Code))
      const optDL = document.createElement('option');
      optDL.value = labelForDatalist(entry);
      dl.appendChild(optDL);

      // select option (shows CODE — Name)
      const optSel = document.createElement('option');
      optSel.value = entry.id;
      optSel.textContent = labelForSelect(entry);
      sel.appendChild(optSel);
    }
  }

  // Given either an id or a text, set the hidden id + display text
  function setEmployeeSelection(by){
    const inp = $('#f_emp_search');
    const hid = $('#f_emp_id');
    const sel = $('#f_emp_select');

    let picked = null;

    if (by && by.id){
      picked = EMP_MAP_BY_ID.get(String(by.id)) || null;
    } else if (by && by.text){
      const t = String(by.text).trim().toLowerCase();
      // try exact datalist label match: Name (Code)
      picked = EMP_LIST.find(e => labelForDatalist(e).toLowerCase() === t)
            || EMP_LIST.find(e => e.name.toLowerCase() === t)
            || EMP_LIST.find(e => e.emp_code && e.emp_code.toLowerCase() === t)
            || null;
    }

    if (picked){
      hid.value = picked.id;
      inp.value = labelForDatalist(picked);
      // sync <select>
      sel.value = picked.id;
      // update header preview (optional, final will be set in loadReport)
      $('#emp_info').textContent = displayEmpHeader(picked);
    }else{
      hid.value = '';
      sel.value = '';
    }
  }

  // Input handlers (typing path)
  function attachInputHandlers(){
    const inp = $('#f_emp_search');
    // Enter → resolve & (optionally) run report
    inp.addEventListener('keydown', (e) => {
      if (e.key === 'Enter'){
        e.preventDefault();
        setEmployeeSelection({ text: inp.value });
        if (!$('#f_emp_id').value){
          toast?.('No matching employee');
          return;
        }
        loadReport();
      }
    });
    // On blur, try to resolve softly (don’t auto-run report)
    inp.addEventListener('blur', () => {
      if (!$('#f_emp_id').value && inp.value.trim()){
        setEmployeeSelection({ text: inp.value });
      }
    });
    // Any typing clears the current selection id (re-validate on enter/blur)
    inp.addEventListener('input', () => { $('#f_emp_id').value = ''; $('#f_emp_select').value=''; });
  }

  // Select handlers (picklist path)
  function attachSelectHandlers(){
    const sel = $('#f_emp_select');
    sel.addEventListener('change', () => {
      const id = sel.value;
      if (id){
        setEmployeeSelection({ id });
      }else{
        $('#f_emp_id').value = '';
        // don’t clear the text for convenience
      }
    });
  }

  async function loadEmployeeDirectory(){
    try{
      const list = await apiGET(`${EMP}?status=active`);
      populateEmployeeControls(list || []);
    }catch(e){
      console.warn('No /employees endpoint or fetch failed — fallback', e);
      populateEmployeeControls([]);
    }
  }

  /* ==== CORE ==== */
  async function loadReport(){
    const s = $('#f_start').value, e = $('#f_end').value;
    if (!s || !e) { toast?.('Select pay period'); return; }

    const empId = ($('#f_emp_id').value || '').trim();
    if (!empId) { toast?.('Select employee'); return; }

    // fetch employee by id (for header)
    const emp = await apiGET(`${EMP}/${empId}`);
    $('#emp_info').textContent = emp ? (emp.name || '') : '';

    // build TE query
    let qs = `${TE}/range?start_at=${encodeURIComponent(toISODate(s))}&end_at=${encodeURIComponent(toISODateEndExclusive(e))}`;
    qs += `&employee_id=${encodeURIComponent(empId)}`;
    qs += `&status=active`;

    let items = await apiGET(qs);

    const closedOnly = $('#f_closed_only').checked;
    if (closedOnly) { items = items.filter(x => x.status === 'closed' && x.clock_in_at && x.clock_out_at); }

    const empSetForRates = new Set(items.map(x=>x.employee_id));
    if ($('#f_use_rate_db').checked) { await loadRatesForEmployees(empSetForRates); }

    const groups = new Map();
    for (const te of items) {
      const key = `${te.employee_id}|${localDateKey(te.clock_in_at)}`;
      if (!groups.has(key)) groups.set(key, { employee_id: te.employee_id, date: localDateKey(te.clock_in_at), entries: [] });
      groups.get(key).entries.push(te);
    }

    const rows = [];
    for (const g of groups.values()) {
      const entries = g.entries;
      const earliestIn = entries.map(x => x.clock_in_at).filter(Boolean).sort()[0] || null;
      const latestOut  = entries.map(x => x.clock_out_at).filter(Boolean).sort().slice(-1)[0] || null;

      const grossHours = sum(entries.map(x => durHours(x.clock_in_at, x.clock_out_at)));
      const unpaidBreakHours = sum(entries.flatMap(x => (Array.isArray(x.breaks)? x.breaks:[])
                                          .filter(b => b && b.start_at && b.end_at && !b.is_paid)
                                          .map(b => durHours(b.start_at, b.end_at))));
      const netHours = Math.max(0, grossHours - unpaidBreakHours);

      let rateVal = null, otMult = DEFAULT_OT_MULTIPLIER;
      if ($('#f_use_rate_db').checked) {
        const er = effectiveRateFor(g.employee_id, earliestIn || (g.date ? `${g.date}T00:00:00` : null));
        if (er && er.hourly_rate != null) { rateVal = parseFloat(er.hourly_rate); }
        if (er && er.ot_multiplier != null) otMult = parseFloat(er.ot_multiplier) || otMult;
      }
      const overrides = getOverrides();
      if (overrides[g.employee_id] != null) { rateVal = parseFloat(overrides[g.employee_id]); }
      if (rateVal == null || isNaN(rateVal)) rateVal = parseFloat($('#f_rate').value || '0');

      const { regHours, ot1Hours } = splitDailyHours(netHours);
      const otRate = rateVal * otMult;
      const payReg = regHours * rateVal;
      const payOT  = ot1Hours * otRate;
      const payTot = payReg + payOT;

      rows.push({
        employee_id: g.employee_id,
        date: g.date,
        earliestIn,
        latestOut,
        unpaidBreakCount: entries.reduce((acc, x) => acc + (Array.isArray(x.breaks) ? x.breaks.filter(b => b && !b.is_paid && b.start_at && b.end_at).length : 0), 0),
        unpaidBreakHours,
        netHours,
        regHours, ot1Hours,
        rate: rateVal,
        otRate,
        payReg, payOT, payTot,
        entries
      });
    }

    render(rows);
  }

  function render(rows){
    const tb = $('#tblBody'); tb.innerHTML='';
    let totalNet=0,totalReg=0,totalOT=0,totalPayReg=0,totalPayOT=0,grand=0;

    for(const r of rows.sort((a,b)=> (a.date===b.date? a.employee_id-b.employee_id : a.date.localeCompare(b.date)))){
      totalNet+=r.netHours; totalReg+=r.regHours; totalOT+=r.ot1Hours;
      totalPayReg+=r.payReg; totalPayOT+=r.payOT; grand+=r.payTot;

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><button class="btn" style="padding:4px 8px" onclick="toggleDetails(this)">▶</button></td>
        <td class="nowrap">${esc(r.date)}</td>
        <td>${esc(fmtTime(r.earliestIn))}</td>
        <td>${esc(fmtTime(r.latestOut))}</td>
        <td>
          <span class="chip">${r.unpaidBreakCount} lists</span>
          <span class="chip">${r.unpaidBreakHours.toFixed(2)} h</span>
        </td>
        <td class="num">${r.regHours.toFixed(2)}</td>
        <td class="num">${r.ot1Hours.toFixed(2)}</td>
        <td class="num">
          <input type="number" step="0.01" value="${isNaN(r.rate)?'':r.rate}" style="width:110px;text-align:right"
                 oninput="setRate(${r.employee_id}, this.value)">
        </td>
        <td class="num mono">${currency(r.otRate)}</td>
        <td class="num mono">${currency(r.payReg)}</td>
        <td class="num mono">${currency(r.payOT)}</td>
        <td class="num mono">${currency(r.payTot)}</td>`;
      tb.appendChild(tr);

      const dtr = document.createElement('tr'); dtr.className = 'details hidden';
      dtr.innerHTML = `<td></td><td colspan="12">${renderDetails(r)}</td>`;
      tb.appendChild(dtr);
    }

    $('#sumHours').textContent = totalNet.toFixed(2);
    $('#sumPay').textContent   = currency(grand);

    $('#tblFoot').innerHTML = `
      <tr>
        <td colspan="5" class="num">Total</td>
        <td class="num">${totalReg.toFixed(2)}</td>
        <td class="num">${totalOT.toFixed(2)}</td>
        <td></td>
        <td></td>
        <td class="num mono">${currency(totalPayReg)}</td>
        <td class="num mono">${currency(totalPayOT)}</td>
        <td class="num mono">${currency(grand)}</td>
      </tr>`;
  }

  function toggleDetails(btn){
    const tr = btn.closest('tr');
    const dtr = tr.nextElementSibling;
    if(!dtr || !dtr.classList.contains('details')) return;
    const open = !dtr.classList.contains('hidden');
    if(open){ dtr.classList.add('hidden'); btn.textContent = '▶'; }
    else { dtr.classList.remove('hidden'); btn.textContent = '▼'; }
  }

  function renderDetails(r){
    let html = '';
    for(const te of r.entries.sort((a,b)=> (a.clock_in_at||'').localeCompare(b.clock_in_at||''))){
      const gross = durHours(te.clock_in_at, te.clock_out_at);
      const unpaid = sum((Array.isArray(te.breaks)? te.breaks:[])
                    .filter(b => b && b.start_at && b.end_at && !b.is_paid)
                    .map(b => durHours(b.start_at, b.end_at)));
      html += `<div style="margin-bottom:8px">`
        + `<div class="mono">TE#${te.id} · ${esc(te.status||'')} · ${esc(te.clock_in_method||'')} → ${esc(te.clock_out_method||'')}</div>`
        + `<div>⏱️ ${esc(fmtTime(te.clock_in_at))} - ${esc(fmtTime(te.clock_out_at))} <span class="muted">(gross ${gross.toFixed(2)} h, unpaid break ${unpaid.toFixed(2)} h)</span></div>`
        + renderBreaks(te.breaks)
        + `</div>`;
    }
    html += `<div class="small"><strong>Date sumarry:</strong> Reg ${r.regHours.toFixed(2)}h, OT ${r.ot1Hours.toFixed(2)}h · `
         + `Rate ${currency(r.rate)}, OT Rate ${currency(r.otRate)} · `
         + `Pay ${currency(r.payTot)}</div>`;
    return html || '<span class="muted">ไม่มีรายละเอียด</span>';
  }

  function renderBreaks(breaks){
    const arr = Array.isArray(breaks)? breaks.filter(Boolean): [];
    if(!arr.length) return '<div class="small muted">— no breaks —</div>';
    let html = '<div class="small">';
    for(const b of arr){
      const d = durHours(b.start_at, b.end_at);
      const tag = b.is_paid ? 'paid' : 'unpaid';
      html += `<div>• [${esc(b.break_type||'break')}/${tag}] ${esc(fmtTime(b.start_at))} - ${esc(fmtTime(b.end_at))} (${isNaN(d)?'0.00':d.toFixed(2)} h)</div>`;
    }
    html += '</div>';
    return html;
  }

  function setRate(empId, v){
    const ov = getOverrides();
    const num = parseFloat(v);
    if(isNaN(num)) delete ov[empId]; else ov[empId] = num;
    setOverrides(ov);
    loadReport();
  }

  function exportCSV(){
    const rows = [];
    const tb = document.querySelector('#tblBody');
    const trs = Array.from(tb.querySelectorAll('tr')).filter((_, i) => i % 2 === 0);

    for (const tr of trs) {
      const tds = tr.querySelectorAll('td');
      const date = (tds[1]?.textContent || '').trim();
      const clockIn  = (tds[2]?.textContent || '').trim();
      const clockOut = (tds[3]?.textContent || '').trim();
      const breakTxt = (tds[4]?.textContent || '').trim();
      const regH     = (tds[5]?.textContent || '').trim();
      const otH      = (tds[6]?.textContent || '').trim();
      const rate     = tr.querySelector('input[type="number"]')?.value || '';
      const otRate   = (tds[8]?.textContent || '').trim();
      const payReg   = (tds[9]?.textContent || '').trim();
      const payOT    = (tds[10]?.textContent || '').trim();
      const payTotal = (tds[11]?.textContent || '').trim();
      rows.push([date, clockIn, clockOut, breakTxt, regH, otH, rate, otRate, payReg, payOT, payTotal]);
    }

    const header = [
      'date','clock_in','clock_out','break_unpaid',
      'reg_hours','ot_hours','rate','ot_rate',
      `amount_reg(${CCY_SYM})`, `amount_ot(${CCY_SYM})`, `amount_total(${CCY_SYM})`
    ];

    const csv = [header, ...rows]
      .map(r => r.map(v => `"${String(v).replace(/"/g, '""')}"`).join(','))
      .join('\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `payroll_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  /* ==== INIT ==== */
  (async function init(){
    const today = new Date();
    const ymd = toLocalISODate(today);
    $('#f_start').value = ymd;
    $('#f_end').value = ymd;

    attachInputHandlers();
    attachSelectHandlers();

    await loadEmployeeDirectory();
    await loadPayPeriods();
    if(PAY_PERIODS.length){ $('#f_period').value = PAY_PERIODS[0].id; onPeriodChange(); }
  })();

  // Expose inline handlers
  Object.assign(window, { loadReport, exportCSV, onPeriodChange, toggleDetails, setRate });
</script>
</body>
</html>
