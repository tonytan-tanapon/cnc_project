<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Payroll Report (Per-Employee Per-Day) — DB Pay Period & Rates (OT Included)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{--text:#111;--muted:#6b7280;--line:#e5e7eb;--btn:#374151;--acc:#2563eb;--ok:#16a34a;--warn:#d97706;--err:#b91c1c;--bg:#fff}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .wrap{max-width:1200px;margin:28px auto;padding:0 14px}
    h1{margin:0 0 12px;font-size:22px}
    .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:14px;margin-bottom:14px}
    label{display:block;margin:6px 0 4px;font-weight:600}
    input,select,textarea{width:100%;padding:9px 11px;border:1px solid var(--line);border-radius:10px;background:#fff}
    input:focus,select:focus,textarea:focus{outline:2px solid #c7d2fe;border-color:#c7d2fe}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:end}
    .btn{border:none;border-radius:10px;padding:9px 12px;cursor:pointer;font-weight:700;color:#fff;background:var(--btn)}
    .btn.acc{background:var(--acc)} .btn.ok{background:var(--ok)} .btn.warn{background:var(--warn)} .btn.err{background:var(--err)}
    table{width:100%;border-collapse:collapse;border:1px solid var(--line);border-radius:12px;overflow:hidden}
    th,td{padding:10px 12px;border-bottom:1px solid var(--line);vertical-align:top;text-align:left}
    th{background:#f9fafb}
    tfoot td{background:#f3f4f6;font-weight:700}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .right{margin-left:auto}
    .hidden{display:none}
    .sum{font-weight:700}
    .nowrap{white-space:nowrap}
    .num{text-align:right}
    .chip{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef2ff;border:1px solid #e5e7eb;font-size:12px}
    tr.details{background:#fbfbff}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Payroll Report</h1>

  <!-- Filters -->
  <div class="card">
    <div class="row">
      <div style="min-width:240px">
        <label>Employee</label>
        <div style="display:flex; gap:6px; align-items:center">
          <input id="f_emp" type="text" list="emp_suggest" placeholder="Name or id or code" autocomplete="off">
          <input id="f_emp_id" type="hidden">
          <datalist id="emp_suggest"></datalist>
        </div>
      </div>

      <div style="min-width:260px">
        <label>Pay Period</label>
        <select id="f_period" onchange="onPeriodChange()">
          <option value="">Pay Period —</option>
        </select>
      </div>
      <div style="min-width:210px">
        <label>Start (date)</label>
        <input id="f_start" type="date">
      </div>
      <div style="min-width:210px">
        <label>End (date)</label>
        <input id="f_end" type="date">
      </div>

      <div style="min-width:180px">
        <label class="small muted" style="display:flex;align-items:center;gap:8px">
          <input id="f_use_rate_db" type="checkbox" checked>Rate from database
        </label>
      </div>
      <div style="min-width:160px">
        <label>Default Rate</label>
        <input id="f_rate" type="number" step="0.01" value="10">
      </div>

      <div style="min-width:260px">
        <label>&nbsp;</label>
        <div class="row" style="gap:6px">
          <label class="small muted" style="display:flex;align-items:center;gap:8px">
            <input id="f_closed_only" type="checkbox" checked>Close TimeEntry
          </label>
          <button class="btn" onclick="loadReport()">Calculate</button>
          <button class="btn ok" onclick="exportCSV()">Export CSV</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Table -->
  <div class="card">
    <div><div id="emp_info"></div></div>
    <div class="row small muted">
      <div class="right">Total hour: <span id="sumHours" class="sum">0.00</span> h · Total pay: <span id="sumPay" class="sum">0.00</span></div>
    </div>
    <table id="tbl">
      <thead>
        <tr>
          <th></th>
          <th class="nowrap">Date</th>
          <th>Clock In</th>
          <th>Clock Out</th>
          <th>Break (unpaid)</th>
          <th class="num">Reg (h)</th>
          <th class="num">OT (h)</th>
          <th class="num">Rate</th>
          <th class="num">OT Rate</th>
          <th class="num">Pay (Reg)</th>
          <th class="num">Pay (OT)</th>
          <th class="num">Total pay</th>
        </tr>
      </thead>
      <tbody id="tblBody"></tbody>
      <tfoot id="tblFoot"></tfoot>
    </table>
  </div>
</div>

<!-- Switch to module to allow imports -->
<script type="module">
  import { $ as _$, jfetch, toast } from "/static/js/api.js?v=1";

  // Local DOM helper
  const $ = (sel) => document.querySelector(sel);

  /* ----------------- API base ----------------- */
  const API_BASE = ''; // change to '' if same origin
  const api = (p) => `${API_BASE}${p}`;

  async function apiGET(path){
    try{
      return await jfetch(api(path));
    }catch(e){
      console.error('API error', e);
      if (typeof toast === 'function') toast(e?.message || 'API error');
      throw e;
    }
  }

  // ==== CONFIG ==== (endpoints)
  const TE = "/time-entries";        // /time-entries/range
  const PP = "/pay-periods";         // GET /pay-periods
  const PR = "/pay-rates";           // GET /pay-rates?employee_id=...
  const PR_BULK = "/pay-rates/bulk"; // GET /pay-rates/bulk?employee_ids=1,2,3
  const EMP = "/employees";          // GET /employees, GET /employees/:id

  // ---- OVERTIME RULE ----
  const DAILY_OT1_THRESHOLD = 8;
  const DEFAULT_OT_MULTIPLIER = 1.5;

  // ==== HELPERS ====
  const esc = s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  const pad = n => String(n).padStart(2,'0');
  function toISODate(d){ return d ? d + "T00:00:00" : null; }
  function toISODateEndExclusive(d){ return d ? addDaysStr(d,1) + "T00:00:00" : null; }
  function addDaysStr(yyyy_mm_dd, days){ const dt = new Date(yyyy_mm_dd+"T00:00:00"); dt.setDate(dt.getDate()+days); return toLocalISODate(dt); }
  function toLocalISODate(dt){ const y = dt.getFullYear(), m = pad(dt.getMonth()+1), d = pad(dt.getDate()); return `${y}-${m}-${d}`; }
  function localDateKey(iso){ const d = new Date(iso); if(isNaN(d)) return ''; return toLocalISODate(d); }
  function fmtTime(iso){ if(!iso) return ''; const d=new Date(iso); if(isNaN(d)) return ''; return `${pad(d.getHours())}:${pad(d.getMinutes())}`; }
  function durHours(isoStart, isoEnd){ if(!isoStart || !isoEnd) return 0; const s=new Date(isoStart), e=new Date(isoEnd); if(isNaN(s)||isNaN(e)||e<=s) return 0; return (e-s)/3600000; }
  function sum(arr){ return arr.reduce((a,b)=>a+b,0); }
  const CCY_SYM = '$';
  function currency(v){ return CCY_SYM + ' ' + Number(v||0).toFixed(2); }

  function getOverrides(){ try{ return JSON.parse(localStorage.getItem('payroll_rate_overrides')||'{}'); }catch{ return {}; } }
  function setOverrides(map){ localStorage.setItem('payroll_rate_overrides', JSON.stringify(map||{})); }
  function openDatalist(inp){
  // Prefer native picker if available
  if (typeof inp.showPicker === 'function') {
    try { inp.showPicker(); } catch {}
    setTimeout(() => { try { inp.showPicker(); } catch {} }, 0);
    return;
  }
  // Fallback: clear and nudge with ArrowDown so ALL options show
  const ev = new KeyboardEvent('keydown', {key:'ArrowDown', bubbles:true});
  inp.dispatchEvent(ev);
  setTimeout(() => inp.dispatchEvent(ev), 0);
}
  // ---- EMP DIRECTORY MAP ----
  // label -> { id, name, emp_code }
  const EMP_MAP = new Map();

  const empLabel = (e) => {
    const parts = [];
    if (e.name) parts.push(e.name);
    // if (e.emp_code) parts.push(`(${e.emp_code})`);
    return parts.join(' ').trim() ;
  };

  function resolveEmployeeSelection() {
    const $emp = $('#f_emp');
    const $empId = $('#f_emp_id');
    const typed = ($emp.value || '').trim();

    // exact label match
    const meta1 = EMP_MAP.get(typed);
    console.log(meta1)
    if (meta1) {
      $empId.value = meta1.id;
      if (meta1.emp_code) $emp.value = meta1.name; // show code
      return;
    }
    // user typed id or code
    let meta2 = null;
    for (const v of EMP_MAP.values()) {
      if (String(v.id) === typed || (v.emp_code && v.emp_code === typed)) { meta2 = v; break; }
    }
    if (meta2) {
      $empId.value = meta2.id;
      if (meta2.emp_code) $emp.value = meta2.emp_code;
      return;
    }
    // unknown
    $empId.value = '';
  }

  // ==== PAY PERIOD ====
  let PAY_PERIODS = [];
  async function loadPayPeriods(){
    try{
      PAY_PERIODS = await apiGET(PP);
      const sel = $('#f_period');
      PAY_PERIODS.sort((a,b)=> (b.start_at||'').localeCompare(a.start_at||''));
      for(const p of PAY_PERIODS){
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = `${p.name||p.id} — ${toLocalISODate(new Date(p.start_at))} → ${toLocalISODate(new Date(p.end_at))} (${p.status||''})`;
        sel.appendChild(opt);
      }
    }catch(e){ console.warn('loadPayPeriods failed', e); }
  }

  function onPeriodChange(){
    const id = $('#f_period').value;
    if(!id) return;
    const p = PAY_PERIODS.find(x => String(x.id) === String(id));
    if(!p) return;

    const start = new Date(p.start_at);
    const end   = new Date(p.end_at);

    let days = Math.ceil((end - start) / 86400000);
    if (!Number.isFinite(days) || days < 1) days = 1;

    const endInclusive = new Date(start);
    endInclusive.setDate(start.getDate() + days );

    $('#f_start').value = toLocalISODate(start);
    $('#f_end').value   = toLocalISODate(endInclusive);
  }

  // ==== PAY RATES ====
  let PAY_RATES = {};

  async function loadRatesForEmployees(empIds){
    const ids = Array.from(empIds||[]).map(x=>String(x));
    if(!ids.length){ PAY_RATES = {}; return; }

    try{
      const data = await apiGET(`${PR_BULK}?employee_ids=${encodeURIComponent(ids.join(','))}`);
      PAY_RATES = {};
      for(const row of (data||[])){
        const eid = row.employee_id;
        if(!PAY_RATES[eid]) PAY_RATES[eid] = [];
        PAY_RATES[eid].push(row);
      }
      for(const k in PAY_RATES){
        PAY_RATES[k].sort((a,b)=> (a.effective_from||'').localeCompare(b.effective_from||''));
      }
      return;
    }catch(e){ /* fallback */ }

    PAY_RATES = {};
    for(const eid of ids){
      try{
        const list = await apiGET(`${PR}?employee_id=${encodeURIComponent(eid)}`);
        PAY_RATES[eid] = (list||[]).sort((a,b)=> (a.effective_from||'').localeCompare(b.effective_from||''));
      }catch(err){ console.warn('loadRates emp failed', eid, err); PAY_RATES[eid] = []; }
    }
  }

  function effectiveRateFor(empId, atIso){
    const arr = PAY_RATES[empId]||[];
    if(!arr.length) return null;
    const at = atIso ? new Date(atIso) : null;
    let chosen = null;
    for(const r of arr){
      if(!r.effective_from){ chosen = r; continue; }
      const eff = new Date(r.effective_from);
      if(!at || eff <= at){ chosen = r; } else { break; }
    }
    return chosen;
  }

  function splitDailyHours(net){
    const reg = Math.max(0, Math.min(net, DAILY_OT1_THRESHOLD));
    const ot  = Math.max(0, net - DAILY_OT1_THRESHOLD);
    return { regHours: reg, ot1Hours: ot };
  }

  // ==== CORE ====
  async function loadReport(){
    const s = $('#f_start').value, e = $('#f_end').value;
    if (!s || !e) { toast?.('Select pay period'); return; }

    const empId = ($('#f_emp_id').value || '').trim();
    if (!empId) { toast?.('Select employee'); return; }

    // fetch employee by id
    const emp = await apiGET(`${EMP}/${empId}`);
    // emp_info.innerHTML = `${esc(emp.name)} ${emp.emp_code ? '('+esc(emp.emp_code)+')' : ''}`;
    emp_info.innerHTML = esc(emp.name||'');
    // build TE query
    let qs = `${TE}/range?start_at=${encodeURIComponent(toISODate(s))}&end_at=${encodeURIComponent(toISODateEndExclusive(e))}`;
    qs += `&employee_id=${encodeURIComponent(empId)}`;
    qs += `&status=active`;

    let items = await apiGET(qs);

    const closedOnly = $('#f_closed_only').checked;
    if (closedOnly) { items = items.filter(x => x.status === 'closed' && x.clock_in_at && x.clock_out_at); }

    const empSetForRates = new Set(items.map(x=>x.employee_id));
    if ($('#f_use_rate_db').checked) { await loadRatesForEmployees(empSetForRates); }

    const groups = new Map();
    for (const te of items) {
      const key = `${te.employee_id}|${localDateKey(te.clock_in_at)}`;
      if (!groups.has(key)) groups.set(key, { employee_id: te.employee_id, date: localDateKey(te.clock_in_at), entries: [] });
      groups.get(key).entries.push(te);
    }

    const rows = [];
    for (const g of groups.values()) {
      const entries = g.entries;
      const earliestIn = entries.map(x => x.clock_in_at).filter(Boolean).sort()[0] || null;
      const latestOut  = entries.map(x => x.clock_out_at).filter(Boolean).sort().slice(-1)[0] || null;

      const grossHours = sum(entries.map(x => durHours(x.clock_in_at, x.clock_out_at)));
      const unpaidBreakHours = sum(entries.flatMap(x => (Array.isArray(x.breaks)? x.breaks:[])
                                          .filter(b => b && b.start_at && b.end_at && !b.is_paid)
                                          .map(b => durHours(b.start_at, b.end_at))));
      const netHours = Math.max(0, grossHours - unpaidBreakHours);

      let rateVal = null, otMult = DEFAULT_OT_MULTIPLIER;
      let er = null;
      if ($('#f_use_rate_db').checked) {
        er = effectiveRateFor(g.employee_id, earliestIn || (g.date ? `${g.date}T00:00:00` : null));
        if (er && er.hourly_rate != null) { rateVal = parseFloat(er.hourly_rate); }
        if (er && er.ot_multiplier != null) otMult = parseFloat(er.ot_multiplier) || otMult;
      }
      const overrides = getOverrides();
      if (overrides[g.employee_id] != null) { rateVal = parseFloat(overrides[g.employee_id]); }
      if (rateVal == null || isNaN(rateVal)) rateVal = parseFloat($('#f_rate').value || '0');

      const { regHours, ot1Hours } = splitDailyHours(netHours);
      const otRate = rateVal * otMult;
      const payReg = regHours * rateVal;
      const payOT  = ot1Hours * otRate;
      const payTot = payReg + payOT;

      rows.push({
        employee_id: g.employee_id,
        date: g.date,
        earliestIn,
        latestOut,
        unpaidBreakCount: entries.reduce((acc, x) => acc + (Array.isArray(x.breaks) ? x.breaks.filter(b => b && !b.is_paid && b.start_at && b.end_at).length : 0), 0),
        unpaidBreakHours,
        netHours,
        regHours, ot1Hours,
        rate: rateVal,
        otRate,
        payReg, payOT, payTot,
        entries
      });
    }

    render(rows);
  }

  function render(rows){
    const tb = $('#tblBody'); tb.innerHTML='';

    let totalNet=0,totalReg=0,totalOT=0,totalPayReg=0,totalPayOT=0,grand=0;

    for(const r of rows.sort((a,b)=> (a.date===b.date? a.employee_id-b.employee_id : a.date.localeCompare(b.date)))){
      totalNet+=r.netHours; totalReg+=r.regHours; totalOT+=r.ot1Hours;
      totalPayReg+=r.payReg; totalPayOT+=r.payOT; grand+=r.payTot;

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><button class="btn" style="padding:4px 8px" onclick="toggleDetails(this)">▶</button></td>
        <td class="nowrap">${esc(r.date)}</td>
        <td>${esc(fmtTime(r.earliestIn))}</td>
        <td>${esc(fmtTime(r.latestOut))}</td>
        <td>
          <span class="chip">${r.unpaidBreakCount} lists</span>
          <span class="chip">${r.unpaidBreakHours.toFixed(2)} h</span>
        </td>
        <td class="num">${r.regHours.toFixed(2)}</td>
        <td class="num">${r.ot1Hours.toFixed(2)}</td>
        <td class="num">
          <input type="number" step="0.01" value="${isNaN(r.rate)?'':r.rate}" style="width:110px;text-align:right"
                 oninput="setRate(${r.employee_id}, this.value)">
        </td>
        <td class="num mono">${currency(r.otRate)}</td>
        <td class="num mono">${currency(r.payReg)}</td>
        <td class="num mono">${currency(r.payOT)}</td>
        <td class="num mono">${currency(r.payTot)}</td>`;
      tb.appendChild(tr);

      const dtr = document.createElement('tr'); dtr.className = 'details hidden';
      dtr.innerHTML = `<td></td><td colspan="12">${renderDetails(r)}</td>`;
      tb.appendChild(dtr);
    }

    $('#sumHours').textContent = totalNet.toFixed(2);
    $('#sumPay').textContent   = currency(grand);

    const tf = $('#tblFoot');
    tf.innerHTML = `
      <tr>
        <td colspan="5" class="num">Total</td>
        <td class="num">${totalReg.toFixed(2)}</td>
        <td class="num">${totalOT.toFixed(2)}</td>
        <td></td>
        <td></td>
        <td class="num mono">${currency(totalPayReg)}</td>
        <td class="num mono">${currency(totalPayOT)}</td>
        <td class="num mono">${currency(grand)}</td>
      </tr>`;
  }

  function toggleDetails(btn){
    const tr = btn.closest('tr');
    const dtr = tr.nextElementSibling;
    if(!dtr || !dtr.classList.contains('details')) return;
    const open = !dtr.classList.contains('hidden');
    if(open){ dtr.classList.add('hidden'); btn.textContent = '▶'; }
    else { dtr.classList.remove('hidden'); btn.textContent = '▼'; }
  }

  function renderDetails(r){
    let html = '';
    for(const te of r.entries.sort((a,b)=> (a.clock_in_at||'').localeCompare(b.clock_in_at||''))){
      const gross = durHours(te.clock_in_at, te.clock_out_at);
      const unpaid = sum((Array.isArray(te.breaks)? te.breaks:[])
                    .filter(b => b && b.start_at && b.end_at && !b.is_paid)
                    .map(b => durHours(b.start_at, b.end_at)));
      html += `<div style="margin-bottom:8px">`
        + `<div class="mono">TE#${te.id} · ${esc(te.status||'')} · ${esc(te.clock_in_method||'')} → ${esc(te.clock_out_method||'')}</div>`
        + `<div>⏱️ ${esc(fmtTime(te.clock_in_at))} - ${esc(fmtTime(te.clock_out_at))} <span class="muted">(gross ${gross.toFixed(2)} h, unpaid break ${unpaid.toFixed(2)} h)</span></div>`
        + renderBreaks(te.breaks)
        + `</div>`;
    }
    html += `<div class="small"><strong>Date sumarry:</strong> Reg ${r.regHours.toFixed(2)}h, OT ${r.ot1Hours.toFixed(2)}h · `
         + `Rate ${currency(r.rate)}, OT Rate ${currency(r.otRate)} · `
         + `Pay ${currency(r.payTot)}</div>`;
    return html || '<span class="muted">ไม่มีรายละเอียด</span>';
  }

  function renderBreaks(breaks){
    const arr = Array.isArray(breaks)? breaks.filter(Boolean): [];
    if(!arr.length) return '<div class="small muted">— no breaks —</div>';
    let html = '<div class="small">';
    for(const b of arr){
      const d = durHours(b.start_at, b.end_at);
      const tag = b.is_paid ? 'paid' : 'unpaid';
      html += `<div>• [${esc(b.break_type||'break')}/${tag}] ${esc(fmtTime(b.start_at))} - ${esc(fmtTime(b.end_at))} (${isNaN(d)?'0.00':d.toFixed(2)} h)</div>`;
    }
    html += '</div>';
    return html;
  }

  function setRate(empId, v){
    const ov = getOverrides();
    const num = parseFloat(v);
    if(isNaN(num)) delete ov[empId]; else ov[empId] = num;
    setOverrides(ov);
    loadReport();
  }

  function exportCSV(){
    const rows = [];
    const tb = document.querySelector('#tblBody');
    const trs = Array.from(tb.querySelectorAll('tr')).filter((_, i) => i % 2 === 0);

    for (const tr of trs) {
      const tds = tr.querySelectorAll('td');
      const date = (tds[1]?.textContent || '').trim();
      const clockIn  = (tds[2]?.textContent || '').trim();
      const clockOut = (tds[3]?.textContent || '').trim();
      const breakTxt = (tds[4]?.textContent || '').trim();
      const regH     = (tds[5]?.textContent || '').trim();
      const otH      = (tds[6]?.textContent || '').trim();
      const rate     = tr.querySelector('input[type="number"]')?.value || '';
      const otRate   = (tds[8]?.textContent || '').trim();
      const payReg   = (tds[9]?.textContent || '').trim();
      const payOT    = (tds[10]?.textContent || '').trim();
      const payTotal = (tds[11]?.textContent || '').trim();
      rows.push([date, clockIn, clockOut, breakTxt, regH, otH, rate, otRate, payReg, payOT, payTotal]);
    }

    const header = [
      'date','clock_in','clock_out','break_unpaid',
      'reg_hours','ot_hours','rate','ot_rate',
      `amount_reg(${CCY_SYM})`, `amount_ot(${CCY_SYM})`, `amount_total(${CCY_SYM})`
    ];

    const csv = [header, ...rows]
      .map(r => r.map(v => `"${String(v).replace(/"/g, '""')}"`).join(','))
      .join('\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `payroll_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // ==== EMP SUGGESTIONS ====
  function setEmpSuggestions(arr){
    const dl = document.querySelector('#emp_suggest');
    if (!dl) return;

    dl.innerHTML = '';
    EMP_MAP.clear();

    for (const e of (arr || [])) {
      const label = empLabel(e);
      const opt = document.createElement('option');
      opt.value = label;     // what the user sees/types to select
      opt.dataset.id = e.id; // optional
      dl.appendChild(opt);
      EMP_MAP.set(label, { id: String(e.id), name: e.name, emp_code: e.emp_code });
    }
  }

  async function loadEmployeeDirectory(){
    try{
      const list = await apiGET(`${EMP}?status=active`);
      setEmpSuggestions(list || []);
    }catch(e){ console.warn('No /employees endpoint or fetch failed — fallback', e); }
  }

  function addEmpSuggestionsFromEntries(items){
    const ids = [...new Set((items||[]).map(x => x.employee_id))].map(id => ({id}));
    setEmpSuggestions(ids);
  }

  // ==== INIT ====
  (async function init(){
    const today = new Date();
    const ymd = toLocalISODate(today);
    $('#f_start').value = ymd;
    $('#f_end').value = ymd;

    // key handlers
    $('#f_emp').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); resolveEmployeeSelection(); loadReport(); }
    });

    let _listOpen = false;

const empInput = $('#f_emp');

empInput.addEventListener('pointerdown', (e) => {
  if (document.activeElement === empInput) {
    if (_listOpen) {
      // prevent the browser from reopening it
      e.preventDefault();
      empInput.blur();        // close
      _listOpen = false;
      return;                 // stop here
    }
  }
  // if not open, let it open normally
  _listOpen = true;
});

empInput.addEventListener('blur', () => {
  _listOpen = false;
});

    // typing: if it matches a known label, resolve; else clear id
    $('#f_emp').addEventListener('input', () => {
      const val = ($('#f_emp').value || '');
      if (EMP_MAP.has(val.trim())) {
        resolveEmployeeSelection();
      } else {
        $('#f_emp_id').value = '';
      }
    });

    // resolve on change/blur
    $('#f_emp').addEventListener('change', resolveEmployeeSelection);
    $('#f_emp').addEventListener('blur', (e) => {
      // if nothing selected, restore the last shown value
      if (!$('#f_emp_id').value && _empPrevText) {
        e.target.value = _empPrevText;
      }
    });

    // show all options on focus by inserting a single space (Chrome shows all)
    let _empPrevText = '';
    $('#f_emp').addEventListener('focus', (e) => {
      _empPrevText = e.target.value;      // remember what was shown
      $('#f_emp_id').value = '';          // clear selected id so you can re-select
      e.target.value = '';                // IMPORTANT: clear so list isn't filtered to 1 item
      // open the list with all options
      openDatalist(e.target);
    });


    // load data
    await loadEmployeeDirectory();
    await loadPayPeriods();
    if(PAY_PERIODS.length){ $('#f_period').value = PAY_PERIODS[0].id; onPeriodChange(); }
  })();

  // Expose for inline handlers
  Object.assign(window, { loadReport, exportCSV, onPeriodChange, toggleDetails, setRate });
</script>

</body>
</html>
