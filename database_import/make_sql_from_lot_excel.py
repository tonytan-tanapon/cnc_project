import pandas as pd
from decimal import Decimal
from pathlib import Path
import re
from datetime import datetime

# ====== CONFIG ======
EXCEL_PATH = r"C:\Users\TPSERVER\database\Lot_number.xls"
OUTPUT_SQL = r"C:\Users\TPSERVER\database\lot_import.sql"
SHEET_NAME = 0  # first sheet
ADD_CUSTOMER_LINE_REF = True  # requires a 'customer_line_ref' column on po_lines if True

# ====== Helpers ======
def n(s):
    # robust string normalizer (row scalars only)
    return "" if s is None or (isinstance(s, float) and pd.isna(s)) else str(s).strip()

def parse_date(s):
    s = n(s)
    if not s:
        return None
    for fmt in ("%m/%d/%y", "%m/%d/%Y", "%Y-%m-%d"):
        try:
            d = datetime.strptime(s, fmt).date()
            return d.strftime("%Y-%m-%d")
        except ValueError:
            continue
    # try if it is already a date-like from pandas
    try:
        d = pd.to_datetime(s).date()
        return d.strftime("%Y-%m-%d")
    except Exception:
        return None

def money_to_decimal(v):
    s = n(v)
    if not s:
        return None
    s = s.replace("$", "").replace(",", "").strip()
    if s in ("", "-", "–", "—"):
        return None
    # handle parentheses accounting: (1,234.56) -> -1234.56
    if s.startswith("(") and s.endswith(")"):
        s = "-" + s[1:-1]
    try:
        return str(Decimal(s))
    except Exception:
        return None

def int_or_none(v, allow_float=True):
    s = n(v).replace(",", "").strip()
    if s in ("", "-", "–", "—", "NA", "N/A", "None", "null"):
        return None
    # allow "20.0" etc.
    if not re.fullmatch(r"-?\d+(\.\d+)?", s):
        return None
    return int(float(s)) if allow_float else int(s)

def q(s):
    """single-quote SQL literal with escaping"""
    return "NULL" if s is None or s == "" else "'" + str(s).replace("'", "''") + "'"

def qd(datestr):
    return "NULL" if not datestr else f"DATE {q(datestr)}"

def qn(numstr):
    return "NULL" if numstr is None or str(numstr) == "" else str(numstr)

def clean_rev(s):
    s = n(s)
    return s if s else None

def add_note(existing, extra):
    if not extra:
        return existing
    if not existing:
        return extra
    if extra in existing:
        return existing
    return existing + " | " + extra

# ====== Load Excel ======
df = pd.read_excel(EXCEL_PATH, sheet_name=SHEET_NAME, dtype=str)

# Normalize column names we need
COLS = {
    "Date": "Date",
    "Name": "Customer",
    "Lot#": "LotNo",
    "PO": "PO",
    "Part No.": "PartNo",
    "Part No": "PartNo",   # sometimes header varies
    "Description": "Description",
    "Rev.": "Rev",
    "Rev": "Rev",
    "Due Date": "DueDate",
    "Qty PO": "QtyPO",
    "Price": "Price",
    " Price ": "Price",
    "Total": "Total",
    "FAIR#": "FAIR",
    "Shipped Date": "ShipDate",
    "Qty Shipped": "QtyShipped",
    "Invoice No.": "InvoiceNo",
    "Need/Remark": "Remark",
}

norm_cols = {}
for c in df.columns:
    key = c
    if key in COLS:
        norm_cols[c] = COLS[key]
    else:
        # try strict match ignoring spaces/case
        k2 = re.sub(r"\s+", "", str(c)).lower()
        matched = False
        for raw, std in COLS.items():
            if re.sub(r"\s+", "", raw).lower() == k2:
                norm_cols[c] = std
                matched = True
                break
        if not matched:
            norm_cols[c] = c  # keep original for safety

df = df.rename(columns=norm_cols)

# Filter out mostly empty lines (no customer + no part + no lot)
df = df[(df.get("Customer").notna()) | (df.get("PartNo").notna()) | (df.get("LotNo").notna())].copy()

# ====== Build SQL ======
lines = []
emit = lines.append

emit("-- AUTOGENERATED SQL for Customer Orders/Lots/Shipments/Invoices")
emit("BEGIN;")

for i, r in df.iterrows():
    cust_code = n(r.get("Customer"))
    lot_no = n(r.get("LotNo"))
    po_no = n(r.get("PO"))
    part_no = n(r.get("PartNo"))
    desc = n(r.get("Description"))
    rev = clean_rev(r.get("Rev"))
    order_date = parse_date(r.get("Date"))
    due_date = parse_date(r.get("DueDate"))
    qty_po = int_or_none(r.get("QtyPO"))
    price = money_to_decimal(r.get("Price"))
    total_line = money_to_decimal(r.get("Total"))
    fair = n(r.get("FAIR"))
    ship_date = parse_date(r.get("ShipDate"))
    qty_shipped = int_or_none(r.get("QtyShipped"))
    invoice_no = n(r.get("InvoiceNo"))
    remark = n(r.get("Remark"))

    if not cust_code or not po_no or not part_no:
        # Skip rows that don't carry the critical triad
        continue

    # 1) Customer (code + name same for now; adjust if you have a mapping)
    emit(f"""
-- Row {i+1}: {cust_code} / {po_no} / {part_no} / Lot {lot_no}
INSERT INTO customers (code, name)
VALUES ({q(cust_code)}, {q(cust_code)})
ON CONFLICT (code) DO UPDATE SET name = EXCLUDED.name;
""".strip())

    # 2) Part
    emit(f"""
INSERT INTO parts (part_no, name, status)
VALUES ({q(part_no)}, {q(desc or part_no)}, 'active')
ON CONFLICT (part_no) DO UPDATE SET name = EXCLUDED.name;
""".strip())

    # 3) PartRevision (need part_id first; use subselect)
    if rev:
        emit(f"""
INSERT INTO part_revisions (part_id, rev, is_current)
SELECT p.id, {q(rev)}, FALSE
FROM parts p
WHERE p.part_no = {q(part_no)}
ON CONFLICT (part_id, rev) DO NOTHING;
""".strip())

    # 4) Purchase Order (customer PO)
    # order_date not in your PO; you can add if you want. We'll just ensure the record exists.
    emit(f"""
INSERT INTO purchase_orders (po_number, description, customer_id)
SELECT {q(po_no)}, NULL, c.id
FROM customers c
WHERE c.code = {q(cust_code)}
ON CONFLICT (po_number) DO UPDATE SET customer_id = EXCLUDED.customer_id;
""".strip())

    # 5) PO Line
    # notes: append FAIR + Remark
    notes_parts = []
    if fair:
        notes_parts.append(f"FAIR# {fair}")
    if remark:
        notes_parts.append(remark)
    notes = " | ".join(notes_parts) if notes_parts else None

    # optional extra column for customer line ref (e.g. "7532 Line 1")
    extra_cols = ", customer_line_ref" if ADD_CUSTOMER_LINE_REF else ""
    extra_vals = f", {q(po_no)}" if ADD_CUSTOMER_LINE_REF else ""

    emit(f"""
-- PO Line (part/rev)
INSERT INTO po_lines (po_id, part_id, revision_id, qty_ordered, unit_price, due_date, notes{extra_cols})
SELECT po.id, p.id,
       {"pr.id" if rev else "NULL"},
       {qn(qty_po)}, {qn(price)}, {qd(due_date)}, {q(notes)}{extra_vals}
FROM purchase_orders po
JOIN customers c ON c.id = po.customer_id AND c.code = {q(cust_code)}
JOIN parts p ON p.part_no = {q(part_no)}
{"LEFT JOIN part_revisions pr ON pr.part_id = p.id AND pr.rev = " + q(rev) if rev else ""}
WHERE po.po_number = {q(po_no)}
AND NOT EXISTS (
    SELECT 1 FROM po_lines x
    WHERE x.po_id = po.id
      AND x.part_id = p.id
      {"AND x.revision_id = pr.id" if rev else "AND x.revision_id IS NULL"}
);
""".strip())

    # 6) Production Lot: tie to that POLine via a SELECT (idempotent on lot_no)
    if lot_no:
        emit(f"""
INSERT INTO production_lots (lot_no, po_line_id, planned_qty, status, created_at)
SELECT {q(lot_no)}, pl.id,
       COALESCE({qn(qty_po)}, 0),
       CASE WHEN {qn(qty_shipped)} IS NOT NULL AND {qn(qty_po)} IS NOT NULL AND {qn(qty_shipped)} >= {qn(qty_po)} THEN 'closed' ELSE 'in_process' END,
       NOW()
FROM po_lines pl
JOIN purchase_orders po ON po.id = pl.po_id AND po.po_number = {q(po_no)}
JOIN customers c ON c.id = po.customer_id AND c.code = {q(cust_code)}
JOIN parts p ON p.id = pl.part_id AND p.part_no = {q(part_no)}
{"LEFT JOIN part_revisions pr ON pr.id = pl.revision_id AND pr.rev = " + q(rev) if rev else ""}
WHERE NOT EXISTS (SELECT 1 FROM production_lots l WHERE l.lot_no = {q(lot_no)});
""".strip())

    # 7) Customer Shipment + Item (one shipment per row)
    if ship_date and qty_shipped:
        # Shipment (use package_no = lot_no for lookup)
        emit(f"""
-- Shipment (one per row; package_no = lot_no)
INSERT INTO customer_shipments (po_id, shipped_at, ship_to, carrier, tracking_no, notes, package_no)
SELECT po.id, {qd(ship_date)}, NULL, NULL, NULL, NULL, {q(lot_no if lot_no else f"{po_no}-{part_no}")}
FROM purchase_orders po
JOIN customers c ON c.id = po.customer_id AND c.code = {q(cust_code)}
WHERE po.po_number = {q(po_no)}
AND NOT EXISTS (
    SELECT 1 FROM customer_shipments s
    WHERE s.po_id = po.id
      AND s.shipped_at = {qd(ship_date)}
      AND s.package_no = {q(lot_no if lot_no else f"{po_no}-{part_no}")}
);
""".strip())

        # Shipment item (tie to shipment, poline, lot)
        emit(f"""
INSERT INTO customer_shipment_items (shipment_id, po_line_id, lot_id, qty)
SELECT s.id, pl.id, l.id, {qn(qty_shipped)}
FROM purchase_orders po
JOIN customers c ON c.id = po.customer_id AND c.code = {q(cust_code)}
JOIN po_lines pl ON pl.po_id = po.id
JOIN parts p ON p.id = pl.part_id AND p.part_no = {q(part_no)}
{"LEFT JOIN part_revisions pr ON pr.id = pl.revision_id AND pr.rev = " + q(rev) if rev else ""}
JOIN customer_shipments s ON s.po_id = po.id
    AND s.shipped_at = {qd(ship_date)}
    AND s.package_no = {q(lot_no if lot_no else f"{po_no}-{part_no}")}
LEFT JOIN production_lots l ON l.lot_no = {q(lot_no)} AND l.po_line_id = pl.id
WHERE po.po_number = {q(po_no)}
AND NOT EXISTS (
    SELECT 1 FROM customer_shipment_items si
    WHERE si.shipment_id = s.id
      AND si.po_line_id = pl.id
      AND COALESCE(si.lot_id, -1) = COALESCE(l.id, -1)
);
""".strip())

    # 8) Invoice + lines
    if invoice_no:
        # Invoice header
        emit(f"""
INSERT INTO customer_invoices (invoice_no, po_id, invoice_date, status, notes)
SELECT {q(invoice_no)}, po.id, {qd(ship_date or order_date)}, 'open', NULL
FROM purchase_orders po
JOIN customers c ON c.id = po.customer_id AND c.code = {q(cust_code)}
WHERE po.po_number = {q(po_no)}
ON CONFLICT (invoice_no) DO UPDATE SET po_id = EXCLUDED.po_id;
""".strip())

        # Invoice line
        # amount = unit_price * qty; unit_price comes from poline
        emit(f"""
INSERT INTO customer_invoice_lines (invoice_id, po_line_id, shipment_item_id, qty, unit_price, amount)
SELECT inv.id, pl.id,
       si.id,
       {qn(qty_shipped) if qty_shipped else "COALESCE(pl.qty_ordered, 0)"},
       pl.unit_price,
       ({qn(qty_shipped) if qty_shipped else "COALESCE(pl.qty_ordered, 0)"} * pl.unit_price)
FROM purchase_orders po
JOIN customers c ON c.id = po.customer_id AND c.code = {q(cust_code)}
JOIN po_lines pl ON pl.po_id = po.id
JOIN customer_invoices inv ON inv.po_id = po.id AND inv.invoice_no = {q(invoice_no)}
LEFT JOIN production_lots l ON l.lot_no = {q(lot_no)} AND l.po_line_id = pl.id
LEFT JOIN customer_shipments s ON s.po_id = po.id AND s.package_no = {q(lot_no if lot_no else f"{po_no}-{part_no}")} {"AND s.shipped_at = " + qd(ship_date) if ship_date else ""}
LEFT JOIN customer_shipment_items si ON si.shipment_id = s.id AND si.po_line_id = pl.id AND (si.lot_id = l.id OR (si.lot_id IS NULL AND l.id IS NULL))
WHERE po.po_number = {q(po_no)}
  AND pl.part_id = (SELECT id FROM parts WHERE part_no = {q(part_no)})
  {"AND pl.revision_id = (SELECT id FROM part_revisions WHERE part_id = pl.part_id AND rev = " + q(rev) + ")" if rev else "AND pl.revision_id IS NULL"}
AND NOT EXISTS (
    SELECT 1 FROM customer_invoice_lines xil
    WHERE xil.invoice_id = inv.id
      AND xil.po_line_id = pl.id
      AND COALESCE(xil.shipment_item_id, -1) = COALESCE(si.id, -1)
);
""".strip())

emit("COMMIT;")

# ====== Write file ======
Path(OUTPUT_SQL).parent.mkdir(parents=True, exist_ok=True)
with open(OUTPUT_SQL, "w", encoding="utf-8") as f:
    f.write("\n\n".join(lines))

print(f"Done. Wrote SQL to: {OUTPUT_SQL}")
